import { Floorplan } from '../../types';
import { ImportResult } from './index';
import { readFileAsText } from './fileReader';
import { validateImportedFloorplan } from './validation';
import { migrateData } from '../storage/migrations';
import { v4 as uuidv4 } from 'uuid';

/**
 * Imports a floorplan from a JSON file.
 *
 * @param file The JSON file to import
 * @param options Options for the import
 * @returns Promise resolving to the import result
 */
export async function importFromJSON(
  file: File,
  options: { generateNewIds?: boolean } = {}
): Promise<ImportResult> {
  try {
    const text = await readFileAsText(file);
    let data: any;

    try {
      data = JSON.parse(text);
    } catch (e) {
      return {
        success: false,
        errors: ['Invalid JSON syntax']
      };
    }

    // Handle wrapped export format (from Task 11.2.2)
    // If the file was exported by StrataPlan, it might be wrapped in an object containing metadata
    // Check if there is a 'floorplan' property at the root
    if (data.floorplan && typeof data.floorplan === 'object') {
        data = data.floorplan;
    }

    // Run migrations if needed
    try {
      data = migrateData(data);
    } catch (e) {
      return {
        success: false,
        errors: [`Migration failed: ${e instanceof Error ? e.message : 'Unknown error'}`]
      };
    }

    const validation = validateImportedFloorplan(data);

    if (!validation.valid) {
      return {
        success: false,
        errors: validation.errors,
        warnings: validation.warnings
      };
    }

    let floorplan = data as Floorplan;

    // Ensure arrays exist
    if (!floorplan.doors) floorplan.doors = [];
    if (!floorplan.windows) floorplan.windows = [];

    // Regenerate IDs if requested
    if (options.generateNewIds) {
      floorplan = regenerateIds(floorplan);
    }

    // Convert date strings back to Date objects
    // The validation ensures these exist, but they are strings in JSON
    floorplan.createdAt = new Date(floorplan.createdAt);
    floorplan.updatedAt = new Date(floorplan.updatedAt);

    return {
      success: true,
      floorplan,
      warnings: validation.warnings
    };

  } catch (error) {
    return {
      success: false,
      errors: [error instanceof Error ? error.message : 'Unknown error during JSON import']
    };
  }
}

function regenerateIds(floorplan: Floorplan): Floorplan {
  const newFloorplan = structuredClone(floorplan);
  const idMap = new Map<string, string>();

  // New ID for floorplan itself is usually generated by the storage layer on save
  // but we can generate one here too if we want a fresh start
  newFloorplan.id = uuidv4();

  // Map old room IDs to new ones
  newFloorplan.rooms.forEach(room => {
    const newId = uuidv4();
    idMap.set(room.id, newId);
    room.id = newId;
  });

  // Update doors with new room IDs and generate new door IDs
  if (newFloorplan.doors) {
    newFloorplan.doors.forEach(door => {
      door.id = uuidv4();
      if (idMap.has(door.roomId)) {
        door.roomId = idMap.get(door.roomId)!;
      }
    });
  }

  // Update windows with new room IDs and generate new window IDs
  if (newFloorplan.windows) {
    newFloorplan.windows.forEach(window => {
      window.id = uuidv4();
      if (idMap.has(window.roomId)) {
        window.roomId = idMap.get(window.roomId)!;
      }
    });
  }

  // Update connections with new room IDs
  newFloorplan.connections.forEach(conn => {
    conn.id = uuidv4();

    if (idMap.has(conn.room1Id)) {
      conn.room1Id = idMap.get(conn.room1Id)!;
    }

    if (idMap.has(conn.room2Id)) {
      conn.room2Id = idMap.get(conn.room2Id)!;
    }
  });

  return newFloorplan;
}
