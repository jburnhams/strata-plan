import { Floorplan } from '../../types';
import { ImportResult } from './index';
import { readFileAsText } from './fileReader';
import { validateImportedFloorplan } from './validation';
import { v4 as uuidv4 } from 'uuid';

/**
 * Imports a floorplan from a JSON file.
 *
 * @param file The JSON file to import
 * @param options Options for the import
 * @returns Promise resolving to the import result
 */
export async function importFromJSON(
  file: File,
  options: { generateNewIds?: boolean } = {}
): Promise<ImportResult> {
  try {
    const text = await readFileAsText(file);
    let data: any;

    try {
      data = JSON.parse(text);
    } catch (e) {
      return {
        success: false,
        errors: ['Invalid JSON syntax']
      };
    }

    // Handle wrapped export format (from Task 11.2.2)
    // If the file was exported by StrataPlan, it might be wrapped in an object containing metadata
    // Check if there is a 'floorplan' property at the root
    if (data.floorplan && typeof data.floorplan === 'object') {
        // We could also check data.exportedFrom or data.version here if needed
        data = data.floorplan;
    }

    const validation = validateImportedFloorplan(data);

    if (!validation.valid) {
      return {
        success: false,
        errors: validation.errors,
        warnings: validation.warnings
      };
    }

    let floorplan = data as Floorplan;

    // Regenerate IDs if requested
    if (options.generateNewIds) {
      floorplan = regenerateIds(floorplan);
    }

    // Convert date strings back to Date objects
    // The validation ensures these exist, but they are strings in JSON
    floorplan.createdAt = new Date(floorplan.createdAt);
    floorplan.updatedAt = new Date(floorplan.updatedAt);

    return {
      success: true,
      floorplan,
      warnings: validation.warnings
    };

  } catch (error) {
    return {
      success: false,
      errors: [error instanceof Error ? error.message : 'Unknown error during JSON import']
    };
  }
}

function regenerateIds(floorplan: Floorplan): Floorplan {
  const newFloorplan = structuredClone(floorplan);
  const idMap = new Map<string, string>();

  // New ID for floorplan itself is usually generated by the storage layer on save
  // but we can generate one here too if we want a fresh start
  newFloorplan.id = uuidv4();

  // Map old room IDs to new ones
  newFloorplan.rooms.forEach(room => {
    const newId = uuidv4();
    idMap.set(room.id, newId);
    room.id = newId;

    // Regenerate door/window IDs
    // The Room type doesn't have doors/windows, but if they are nested in import (legacy), we handle it
    if ((room as any).doors) {
      (room as any).doors.forEach((door: any) => {
        door.id = uuidv4();
      });
    }
    if ((room as any).windows) {
      (room as any).windows.forEach((window: any) => {
        window.id = uuidv4();
      });
    }
  });

  // Update connections with new room IDs
  newFloorplan.connections.forEach(conn => {
    conn.id = uuidv4();

    if (idMap.has(conn.room1Id)) {
      conn.room1Id = idMap.get(conn.room1Id)!;
    }

    if (idMap.has(conn.room2Id)) {
      conn.room2Id = idMap.get(conn.room2Id)!;
    }
  });

  return newFloorplan;
}
